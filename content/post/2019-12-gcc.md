---
title: Когда 1.0 = 0.0
date: 2019-12-16T22:49:36-08:00
slug: gcc
tags:
 - Программирование
 - Отладка
---

Столкнулся недавно с новой для себя областью - ловлей багов в компиляторе.
Ловить [баг в процессоре][1] мне уже доводилось, а вот с компиляторами до
недавнего времени как-то везло.

Началось все очень прозаично. В нашем репозитории есть своя реализация умного
указателя. Ну, вы знаете, как это бывает. Обычная история на самом деле...
Этот класс был написан в древние времена, тогда и [С++03][2] еще на свете не
было. С тех пор уже и [С++17][3] появился и [С++20][4] не за горами, но класс
по-прежнему активно используется. Мы его давно хотели заменить на что-нибудь
более стандартное и современное, но все руки не доходили. “Работает - не трожь”.

В один прекрасный день в этом классе нашлось [неопределенное поведение][5], что
стало последней каплей, ~~переломившей верблюду соломинку~~. Указатель был
переписан на корню и стал тонкой оберткой вокруг `std::shared_ptr<>`.
На следующий же день сломался один неприметный юнит тест на одной из платформ.
Причем на первый взгляд никакого отношения к переписанному указателю этот тест
не имел. Но от фактов было трудно отвертеться. С новым указателем тест падал, а
со старым - нет.

<!--more-->

Проблему получилось свести к коду, структура которого выглядела примерно так:

```cpp
bool func1(..., const double foo, ...)
{
    ...
    printf(“func1: foo == %f\n, foo);
    func2(..., foo, ...);
}
 
void func2(..., const double foo, ...)
{
    printf(“func2: foo == %f\n, foo);
    ...
}
```

Этот код печатал следующее:

```
func1: foo == 1.0
func2: foo == 0.0
```

Т.е. буквально до вызова функции константа foo принимала одно значение, а в
вызываемой функции - другое.

Реальный код был сложнее, конечно. Например было важно, чтобы `func1()` была
встроена (inlined) в вызывающий код, а `func2()` - нет. Без соблюдения этого
условия ошибка не воспроизводилась. Более того, добавление еще одного
`printf(“func1: foo == %f\n, foo);` _после_ вызова `func2()` также убирало
проблему. К этому моменту стало довольно очевидно, что компилятор генерирует
что-то не то.

Следующим шагом стал детальный разбор ассемблерного кода, сгенерированного
компилятором. Самым сложным в этом деле оказалось найти правильный справочник
по инструкциям процессора и документ, описывающий соглашение о вызовах на
целевой платформе. Разбор показал, что константа `1.0` правильно загружается в
регистр процессора, но далее значение переписывается другими операциями до
вызова `func2()`.

Поиски в баг-трекере и истории изменений в репозитории GCC не принесли успеха.
Ничего похожего на эту ошибку не находилось. Пришлось отлаживать компилятор
самостоятельно.

В понимании как работает компилятор очень помогла страница [GCC Important
Passes][6]. Если в двух словах, то логика компилятора сгруппирована по
“проходам” (passes). Проходы организованы в две группы: “tree” и “rtl”. Они
используют разные формы представления компилируемого кода: [GIMPLE][7] и
[Register Transfer Language (RTL)][8]. Каждый проход выполняет определенное
преобразование. Например `pass_remove_useless_stmts` удаляет явно бесполезный
код, а `pass_loop2` выполняет оптимизацию циклов.

[![](/2019/12/gcc_passes.png)][6]

Результат работы каждого прохода можно сохранить в файл указав ключи
`-fdump-rtl-all-all` и `-fdump-tree-all-all`. Для каждого прохода создается
отдельный файл, куда пишется весь отладочный вывод вместе с полным описанием
компилируемого модуля на языке GIMPLE или RTL.

Чтобы найти проход, который приводит к ошибке, воспользовался таким алгоритмом
поиска:

* Помечаем проблемный участок для того, чтобы его было легче найти. В данном
  случае достаточно было сделать уникальной строку, которая передается в
  `printf()`.
* Компилируем программу с `-fdump-rtl-all-all` и `-fdump-tree-all-all` и
  получаем несколько сотен файлов с результатами работы каждого прохода.
* Далее ищем проблемный проход методом половинного деления. Все выполненные
  проходы пронумерованы по порядку выполнения.  

Через несколько часов получаем результат - ошибка в коде появляется после
прохода `reload`. Какую роль выполняет проход `reload`? Для начала, согласно
[GCC wiki][9]:

> Reload is the GCC equivalent of Satan.

> Reload - это эквивалент Сатаны в GCC.

С чем я полностью согласен, кстати. В коде `reload` есть условие, которое
занимает [55 строк][10]. Код `reload` обильно припорошен макросами и
полиморфными структурами. Никогда не знаешь какой член объединения (union
member) имеет значение в данном месте. Полное ощущение, что читаешь код на
питоне. Только написанный на чистом C.

Разобраться в этом месиве было бы нереально, но в таких случаях на помощь
приходит [rr][11]. Скажем вам нужно найти место, где создается структура с
заранее известным содержимым. Ставите условную точку останова в теле `free()`,
которая срабатывает по известному содержимому структуры (например четыре байта
по смещению `0x88` равны `0x12345678`). Когда точка останова срабатывает -
проверяете что удаляется искомая структура. Теперь ставите новую условную точку
останова, которая срабатывает по записи в память по адресу, где хранится
`0x12345678` и запускаете обратное выполнение. Бац, и отладчик остановится в
момент создания структуры (в момент записи в нее `0x12345678`).

`reload` принимает на вход код, инструкции в котором используют виртуальные
регистры, каждый из которых [загружается только один раз][12]. Таких регистров
может быть тысячи и десятки тысяч. Задача `reload` преобразовать его в код,
который использует реальные регистры процессора, число которых ограничено
несколькими десятками. Уникальные номера виртуальных регистров позволяют легко
использовать вышеописанную технику, чтобы найти структуры, соответствующие
инструкциям, выполняющим передачу константы `1.0` в `func2()`. А по ним, - найти
места в коде `reload`, которые приводят в генерации некорректного кода на выходе.

Результатом всех этих усилий стала заплатка для GCC, которая выдает
предупреждение компилятора, каждый раз когда `reload` пытается сгенерировать
ошибочный код. Тем самым, у нас появился способ автоматической проверки того,
что подобный код не просочится в итоговую сборку.

Умный указатель, кстати, к ошибке никакого отношения таки не имел. Просто
со старой версией генерировался другой код, который приводил к другой
последовательности использования регистров, с который проблема себя не проявляла.

P.S. Сразу отвечу на очевидный вопрос. В силу специфических особенностей
отрасли, нам даже завести репорт в публичном баг-трекере без юриста никак нельзя.
Да и с юристом это еще тот геморрой.

[1]: {{< relref "2010-07-11-пошли-мы-как-то-с-коллегой-на-охоту….md" >}}
[2]: https://en.wikipedia.org/wiki/C%2B%2B03
[3]: https://en.wikipedia.org/wiki/C%2B%2B17
[4]: https://en.wikipedia.org/wiki/C%2B%2B20
[5]: https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5
[6]: http://stffrdhrn.github.io/software/embedded/openrisc/2018/06/03/gcc_passes.html
[7]: https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html
[8]: https://gcc.gnu.org/onlinedocs/gccint/RTL.html
[9]: https://gcc.gnu.org/wiki/reload
[10]: https://github.com/gcc-mirror/gcc/blob/7057506456ba18f080679b2fe55ec56ee90fd81c/gcc/reload.c#L1056-L1110
[11]: https://rr-project.org/
[12]: https://en.wikipedia.org/wiki/Static_single_assignment_form
