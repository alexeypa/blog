---
author: admin
comments: true
date: 2006-09-11 01:21:41+00:00
excerpt: None
link: http://blog.not-a-kernel-guy.com/2006/09/10/47
slug: windows-powershell
title: Windows PowerShell.
wordpress_id: 47
categories:
- itblogs
tags:
- PowerShell
---

Участие в бесполезном споре Windows vs. Unix иногда приносит пользу. В ответ на [мою реплику](http://alenacpp.blogspot.com/2006/09/microsoft-robotics-studio.html#115751778421825463), некто vansickle поделился ссылкой на [Windows PowerShell](http://www.microsoft.com/windowsserver2003/technologies/management/powershell/default.mspx). В двух словах PowerShell это замена древнему cmd.exe, сочетающая Unix идеологию c Windows технологиями. Учитывая, что мне уже давно не даёт покоя вопрос "когда же, наконец, в Windows сделают нормальную консоль?", я тут же решил попробовать PowerShell вживую.

Первое впечатление после запуска - консоль как консоль. Ничего принципиально не изменилось.

![PowerShell window.](http://blog.not-a-kernel-guy.com/wp-content/uploads/2006/09/powershell_window.png)

Впрочем, быстро стало ясно, что на этом сходство со старой консолью на этом заканчивается. PowerShell реализует основный принцип большинства современных командных оболочек, являясь как бы клеем для множества отдельных утилит, каждая из которых выполняет свой маленький кусочек работы. Командная оболочка лишь предоставляет средства для обмена данными между отдельными утилитами и контроля порядка выполнения команд.

PowerShell использует свой собственный (расширяемый) набор команд - cmdlet-ов. Вместе с тем обеспечивается обратная совместимость с традиционными консольными утилитами. Они работают точно так же как и раньше. Поддерживается механизм альтернативных имен (aliases). Для многих встроенных cmdlet-ов определены "традиционные" имена. Например "cd" - это альтернативное имя для куда менее интуитивного "Set-Location".

Вторая концепция, реализуемая PowerShell, - "навигация - это интерфейс". Любое хранилище данных (файловая система, реестр, переменные окружение) представляется в виде стандартной иерархии элементов и PowerShell предоставляет унифицированные средства для работы с ними. Это очень похоже на концепцию Unix-мира "всё - это файл" с единственным отличием, что в Unix она реализована на системном уровне.

В начале я упомянул, что окно PowerShell мало чем отличается от окна cmd.exe. К сожалению это распространяется и на то, как работает автодополнение (autocompletion), историю команд и буфер обмена. Очень жаль. :-( Из-за этого концепция "навигация - это интерфейс" сильно страдает. Перемещаться по каталогам в том же bash-е не в пример удобнее. Да и редактирование на порядок проще. Впрочем, одно изменение я заметил. PowerShell позволяет редактировать команды, состоящие из нескольких линий. И то хлеб.

Главное отличие PowerShell от других оболочек заключается в том, что она манипулирует объектами, а не текстовыми данными. Это дает гораздо более широкие возможности для обработки данных. Кроме того, это исключает стадию парсинга текстовых данных каждой из цепочки команд, значительно облегчая жизнь разработчикам и упрощая взаимодействие между утилитами. Несколько примеров:

Показать список процессов: 

`get-process`

Показать список методов и свойств объекта, возвращенного командой "get-process explorer": 

`get-process explorer | get-member`

Отсортировать список процессов по возрастанию количества открытых описателей:

`get-process | sort-object handles`

Показать только те процессы, размер working set которых больше 20MB:

`get-process | where-object { $_.get_WorkingSet() -gt 20M }`

Особо показателен второй пример, где видно, что "get-process" возвращает не текстовые данные, а список объектов, каждый из которых имеет свои методы, свойства и вложенные объекты. 

Объектная модель позволила реализовать наиболее "вкусные" особенности PowerShell. PowerShell может работать с .NET и COM объектами, напрямую поддерживает XML, позволяет использовать ADO.NET для доступа к базам данным. Фактически все то, что ранее было доступно .NET программистам теперь доступно прямо в командной оболочке. Замечательный пример - интеграция с WMI. Например, следующая команда выводит информацию о компьютере используя WMI:

`get-wmiobject win32_computersystem`

На моем компьютере она выводит следующее:

![PowerShell and WMI integration.](http://blog.not-a-kernel-guy.com/wp-content/uploads/2006/09/powershell_wmi.png)

Воспользовавшись cmdlet-ом "get-member" можно убедиться, что список свойств не исчерпывается этими 6-ю. На странице [Guy's Scripting Ezine 110 - PowerShell and WMI](http://www.computerperformance.co.uk/ezine/ezine110.htm) есть и другие примеры использования WMI из PowerShell.

Итак, плюсы и минусы PowerShell. Плюсы:

  * Командная оболочка это средство для манипуляции объектами;

  * Унифицированный доступ к файлам, реестру, переменным окружения и т.п.;

  * Развитый язык и средства для работы с данными;

  * Интеграция с .NET и COM

  * Непосредственная поддержка XML;

  * Интеграция с WMI;

  * Расширяемость;

  * Электронная подпись скриптов;

  * Обратная совместимость с существующими утилитами.

Минусы:

  * Неудобное автодополнение и история команд;

  * Буфер обмена не доступен через стандартные Ctrl+C, Ctrl+V, Ctrl+X.

Резюме: однозначно стоит скачать и попробовать.
