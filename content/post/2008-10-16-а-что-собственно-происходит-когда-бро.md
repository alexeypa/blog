---
author: admin
date: 2008-10-16 02:46:41+00:00
excerpt: None
link: http://blog.not-a-kernel-guy.com/2008/10/15/355
slug: а-что-собственно-происходит-когда-бро
title: А что, собственно, происходит, когда бросается исключение?
wordpress_id: 355
tags:
- Обработка исключений
- Windows
---

Нет, ну в общих чертах понятно - процессор генерирует исключение, операционная система находит нужный обработчик и вызывает его. А что происходит, если посмотреть подробнее? В Windows происходит примерно следующее.

Выполняя поток команд, процессор проверят возможность выполнения каждой инструкции, корректность её аргументов и все остальные факторы, влияющие на корректность выполнения кода. В случае если команда не может быть выполнена (деление на ноль, обращение к несуществующей странице, несоответствие уровня привилегий и т.д.), процессор генерирует исключение – вызывает один из обработчиков, зарегистрированных операционной системой в IDT (Interrupt Dispatch Table).

При вызове обработчика процессор делает сразу несколько вещей: переключается в режим ядра (Ring 0), переключает указатель стека на ядерный стек и сохраняет предыдущие указатели команд и стека в ядерном стеке.

![Transition to Ring0](/2008/10/exception_ring0_transition.png)

Получив контроль, обработчик исключения сохраняет остальные регистры процессора в стеке и выполняет действия, специфичные для конкретного исключения. Например, обработчик Page Fault Exception запрашивает подкачку страницы у Memory Manager. Если обработчику удалось  разрешить проблему, вызвавшую генерацию исключения, обработчик восстанавливает сохраненное состояние процессора и выполняет возврат в пользовательский код (Ring 3). В противном случае, в дело вступает диспетчер исключений.

Диспетчер исключений размещает структуру CONTEXT в пользовательском стеке и копирует туда сохранённое состояние регистров из ядерного стека. Туда же сохраняется текущее состояние Floating Point регистров. Информация об исключении записывается в структуру EXCEPTION_RECORD. Далее, диспетчер подменяет адрес возврата в пользовательский код адресом диспетчера исключений пользовательского режима и выполняет возврат в Ring 3.

Windows поддерживает специальную структуру, TEB (Thread Environment Block), где хранятся локальные данные потока. Эта структура  доступна из Ring 3 через сегмент FS (или GS для x64). В самом начале этой структуры хранится указатель на список вложенных блоков “__try” и соответствующих им блоков “__except” и “__finally”. Компилятор генерирует код, добавляющий элемент в этот список при входе в блок “__try” и удаляющий при выходе из блока. _(Примечание: справедливо только для x86. 64-х битный код "раскручивает" стек пользуясь сгенерированным компилятором описанием кода.)_

![Transition to Ring0](/2008/10/exception_chain.png)

Получив управление, диспетчер исключений пользовательского режима по очереди опрашивает обработчики из списка, позволяя каждому из них обработать данное исключение. Найдя обработчик, согласившийся обработать исключение, диспетчер исключений выполняет «раскрутку» стека (Stack Unwinding) и передает управление выбранному обработчику. Этот механизм довольно детально описывался во всевозможных статьях о том, как работает SEH (Structured Exception Handling) (например [здесь](http://www.rsdn.ru/article/baseserv/except.xml) или [здесь](http://www.nynaeve.net/?p=113)), так что я не буду останавливаться на этом детально. «Раскрутчик» стека отслеживает текущее состояние (указатель стека и команд, состояние регистров) в локальной копии структуры CONTEXT. По окончанию обработки исключения, состояние из структуры CONTEXT загружается в процессор, завершая обработку исключения.

И это только поверхностное описание. :-)
