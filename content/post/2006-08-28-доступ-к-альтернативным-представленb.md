---
author: admin
comments: true
date: 2006-08-28 14:05:00+00:00
excerpt: None
link: http://blog.not-a-kernel-guy.com/2006/08/28/21
slug: доступ-к-альтернативным-представленb
title: Доступ к альтернативным представлениям реестра.
wordpress_id: 21
categories:
- itblogs
tags:
- Wow64
---

64-битные версии Windows поддерживают два различных представления реестра для 32 и 64-битных приложений. По-умолчанию приложения работают со своим представлением. Также они могут выбирать желаемое представление с помощью флагов KEY_WOW64_32KEY и KEY_WOW64_64KEY. Применение этих флагов кажется очевидным и прямолинейным, однако это не совсем так.

<!-- more -->
Первая сложность – это возможность переключения выбранного представления на лету. Проблема заключается в том, что при переключении путь к ключу меняется по нетривиальному алгоритму. Например, можете ли вы сказать, на какой ключ будет указывать hChild после выполнения следующего кода?


    
    
    <span class="c_KeywordStructure def_StructKeyword def_Keyword">HKEY</span> hParent <span class="c_Symbol def_Symbol">=</span> <span class="c_KeywordConstant def_Constant def_Keyword">NULL</span><span class="c_StructureSymbol def_SymbolStrong def_Symbol">;</span>
    <span class="c_KeywordWin32 c_KeywordLibFunctions def_FunctionKeyword def_Keyword">RegOpenKeyEx</span><span class="c_Symbol def_Symbol">(</span>
        HKEY_LOCAL_MACHINE<span class="c_Symbol def_Symbol">,</span>
        <span class="def_StringEdge def_String">"</span><span class="c_String def_String">SOFTWARE</span><span class="def_StringEdge def_String">"</span><span class="c_Symbol def_Symbol">,</span>
        <span class="def_NumberDec def_Number">0</span><span class="c_Symbol def_Symbol">,</span>
        KEY_READ <span class="c_Symbol def_Symbol">|</span> KEY_WOW64_32KEY<span class="c_Symbol def_Symbol">,</span>
        <span class="c_Symbol def_Symbol">&</span>hParent<span class="c_Symbol def_Symbol">)</span><span class="c_StructureSymbol def_SymbolStrong def_Symbol">;</span>
    
    <span class="c_KeywordStructure def_StructKeyword def_Keyword">HKEY</span> hChild <span class="c_Symbol def_Symbol">=</span> <span class="c_KeywordConstant def_Constant def_Keyword">NULL</span><span class="c_StructureSymbol def_SymbolStrong def_Symbol">;</span>
    <span class="c_KeywordWin32 c_KeywordLibFunctions def_FunctionKeyword def_Keyword">RegOpenKeyEx</span><span class="c_Symbol def_Symbol">(</span>
        hParent<span class="c_Symbol def_Symbol">,</span>
        <span class="def_StringEdge def_String">"</span><span class="c_String def_String">Microsoft</span><span class="def_StringEdge def_String">"</span><span class="c_Symbol def_Symbol">,</span>
        <span class="def_NumberDec def_Number">0</span><span class="c_Symbol def_Symbol">,</span>
        KEY_READ <span class="c_Symbol def_Symbol">|</span> KEY_WOW64_64KEY<span class="c_Symbol def_Symbol">,</span>
        <span class="c_Symbol def_Symbol">&</span>hChild<span class="c_Symbol def_Symbol">)</span><span class="c_StructureSymbol def_SymbolStrong def_Symbol">;</span>



Будет это «HKLM\SOFTWARE\Microsoft» или «HKLM\SOFTWARE\Wow6432Node\Microsoft»? Для предотвращения этой проблемы рекомендуется избегать переключения выбранного представления на лету. Комбинация флагов KEY_WOW64_XXKEY использованная для открытия или создания родительского ключа должна использоваться и для всех подчиненных ключей.

Вторая сложность – за выбор желаемого представления реестра отвечают разные компоненты в случае 32 и 64-битных приложений. В случае 32-битных приложений wow64.dll перехватывает вызовы функций NtCreateKey и NtOpenKey, добавляя необходимую функциональность. 64-битные приложения используют вспомогательные функции из advapi32.dll, которые вызываются 64-битными реализациями функций RegCreateKeyEx, RegOpenKeyEx и RegDeleteKeyEx. Иными словами если 64-битное приложение использует функции Native API напрямую оно должно быть готово к тому, что NtCreateKey и NtOpenKey ничего не знают о разных представлениях реестра.
