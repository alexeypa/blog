---
author: admin
comments: true
date: 2012-02-22 07:06:47+00:00
excerpt: None
link: http://blog.not-a-kernel-guy.com/2012/02/21/1267
slug: уведомления-о-смене-состояния
title: Уведомления о смене состояния.
wordpress_id: 1267
categories:
- itblogs
tags:
- Программирование
---

А давайте разберем антипаттерн - реализацию механизма уведомления о смене состояния чего-либо с помощью очереди сообщений. Для примера возьмем [Session Change Notifications](http://msdn.microsoft.com/en-us/library/windows/desktop/bb530723(v=vs.85).aspx) в Windows. Пример, как очевидно, совершенно произвольный и не имеющий никакого отношения к тому, что я их сегодня полдня ковырял. :-)

По идее, все просто. Хотим отслеживать состояние сессий - регистрируем окошко или [обработчик](http://msdn.microsoft.com/en-us/library/windows/desktop/ms683241(v=vs.85).aspx), куда будут посылаться уведомления о смене состояния сессий и все дела. Если присмотреться, то все не так просто. Как, к примеру, синхронизировать [получение начального состояния всех сессий](http://msdn.microsoft.com/en-us/library/windows/desktop/ee621014(v=vs.85).aspx) и установку обработчика? Оба действия не атомарны и, следовательно, можно либо пропустить некоторые уведомления, либо получить уведомления, уже учтенные начальным состоянием сессий. Или другая проблема: состояние сессии, вычисленное по полученным уведомлениям может не соответствовать актуальному состоянию сессии. Т.е. получаем WTS_SESSION_LOGON, а сессия уже давно завершилась и даже соответствующее уведомление было послано, просто сообщение все еще сидит в очереди оконных сообщений необработанное. Именно с сессиями, такое вряд ли конечно может случиться на практике. Слишком они тяжеловесны. Но теоретически такое возможно. Хотя стресс тесты и не такое, бывает, находят.

Возникает вопрос, а что же делать? Одно из возможных решений - разделить доставку уведомления о смене состояния и получение текущего состояния. Получение уведомления будет означать, что состояние, возможно, поменялось. Обработчик уведомления должен будет опросить текущее состояние и сравнить его с сохраненной копией. Опять же, в моем случае, все что мне нужно было отследить - это номер сессии, присоединенной в физической консоли. Для этого есть отдельная, и очень эффективная функция - [WTSGetActiveConsoleSessionId()](http://msdn.microsoft.com/en-us/library/windows/desktop/aa383835(v=vs.85).aspx). Вот её полный листинг:

```no-highlight
0:000> uf kernel32!WTSGetActiveConsoleSessionId
kernel32!WTSGetActiveConsoleSessionId:
75133f49 a1d802fe7f      mov     eax,dword ptr [SharedUserData+0x2d8 (7ffe02d8)]
75133f4e c3              ret
```

:-)

При таком подходе представления обработчика о текущем состоянии гораздо ближе к реальности, однако некоторые переходы между состояниями могут быть пропущены. В прочем, для асинхронных уведомлений это возможно в любом случае.
