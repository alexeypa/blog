---
author: admin
date: 2010-10-28 08:37:35+00:00
link: http://blog.not-a-kernel-guy.com/2010/10/28/906
slug: обход-некоторых-ограничений-утилиты-buil
title: Обход некоторых ограничений утилиты BUILD
wordpress_id: 906
tags:
- BUILD
- WDK
---

Система сборки в [Windows Driver Kit](http://www.microsoft.com/whdc/devtools/WDK/default.mspx) базируется на [утилите BUILD](http://msdn.microsoft.com/en-us/library/ff542351(VS.85).aspx). Эта утилита сканирует структуру проектов, отслеживает зависимости (к сожалению далеко не все) и подготавливает окружение для запуска [NMAKE](http://msdn.microsoft.com/en-us/library/dd9y37ha.aspx), который, собственно, и выполняет всю черновую работу по сборке. К сожалению, BUILD создавался и развивался по принципу «так получилось», исключительно эволюционным путем – как средство сборки исходников Windows. Так что эта утилита некоторыми неудобными ограничениями.

Одно из них – полное непонимание переменных и директив препроцессора. К примеру, нужно исключить определённую директорию из дерева сборки если объявлен макрос NOBUILD. Пишем вот такой DIRS файл:

```no-highlight
!if defined(NOBUILD) 

DIRS = \
    foo \

!else

DIRS = \
    foo \
    bar \

!endif
```

Вне зависимости от того, объявлен макрос NOBUILD или нет, BUILD попытается собрать обе директории foo и bar. Более того, вот такой DIRS файл тоже не вызовет ошибку:

```no-highlight
Some random garbage in DIRS file.

DIRS = \
    foo \
    bar \

More random garbage.
```

Почему? Потому, что BUILD просто сканирует файл в поиске текста, похожего на объявление директив DIRS и OPTIONAL_DIRS игнорируя остальной текст. Впрочем, макроподстановки разворачиваются правильно:

```no-highlight
FOO = \
    foo \

DIRS = \
    $(FOO) \
    bar \
```

Аналогичная ситуация с файлом SOURCES. BUILD игнорирует директивы препроцессора, интересуясь только объявлением макроса SOURCES и его платформо-зависимых вариантов. Полностью, все эти директивы обрабатываются только утилитой NMAKE. Как же быть?

Каждая директория, предназначенная для сборки, содержит файл MAKEFILE:

```no-highlight
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE $(NTMAKEENV)\makefile.def
```

Именно этот файл читается NMAKE, для каждого из трех проходов (PASS0, PASS1 и PASS2). По умолчанию, он просто включает стандартные правила сборки, работающие с SOURCES. (Начиная с WDK для Vista MAKEFILE стал опциональным. В случае его отсутствия, автоматически используется MAKEFILE.DEF.) Примерное дерево включений make-файлов выглядит вот так:

```no-highlight
MAKEFILE
+- MAKEFILE.DEF
   +- MAKEFILE.NEW
      +- MAKEFILE.PLT
         +- PROJECT.MK
      +- SOURCES
      +- _OBJECTS.MAC
      +- $(TARGET_DIRECTORY)mk.inc
      +- MAKEFILE.INC
      +- …
```

Откуда видно, что MAKEFILE и MAKEFILE.INC – крайне полезны для нетривиальных манипуляций с логикой сборки. Так, чтобы решить оригинальную задачу, достаточно не включать MAKEFILE.DEF в случае, если объявлен макрос NOBUILD:

```no-highlight
!if !defined(NOBUILD)

#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of Windows NT
#
!INCLUDE $(NTMAKEENV)\makefile.def

!endif
```

В результате, BUILD по-прежнему вызовет NMAKE, но тот проигнорирует данную директорию.
